package com.leetcode2.org.动态规划;

public class Solution600 {
    public int findIntegers(int n) {
        // 预处理斐波那契数列，只计算到第30个斐波那契数，因为更大的斐波那契数会超过int的范围
        int[] fib = new int[31];
        fib[0] = 1; // 斐波那契数列的第一个数
        fib[1] = 2; // 斐波那契数列的第二个数
        for (int i = 2; i < 31; i++) {
            // 从第三个数开始，每个数都是前两个数的和
            fib[i] = fib[i - 1] + fib[i - 2];
        }

        int ans = 0; // 计数满足条件的整数个数
        int k = 30; // 从斐波那契数列的最后一个数开始检查
        int pre = 0; // 标记前一个斐波那契数是否已被考虑（用于处理重复计数问题）

        // 遍历斐波那契数列（从大到小），检查n的二进制表示中的每一位
        while (k >= 0) {
            // 检查n的当前位（从最高位开始）是否为1
            if ((n & (1 << k)) != 0) {
                // 如果当前位为1，说明n中包含了fib[k]这一项
                // 注意：这里不能直接加fib[k]，因为可能存在重复计数的问题
                // 例如，当n为10时，它包含fib[3] = 5和fib[2] = 3，但直接加fib[3]会重复计算fib[2]
                // 因此，我们先加上fib[k]，如果前一个斐波那契数也被包含（pre为1），则减去一个最小的斐波那契数（fib[2] = 2）
                // 但由于我们已经从大到小遍历，所以只需要考虑fib[k]即可，如果前一个斐波那契数也被包含，则结束循环
                ans += fib[k];
                if (pre == 1) {
                    // 如果前一个斐波那契数也被包含，则减去一个重复的计数（这里简化为直接结束循环，因为我们已经考虑了fib[k]）
                    // 但实际上，由于我们是从大到小遍历，且斐波那契数列是递增的，所以只需要确保不重复加fib[k]即可
                    // 这里直接break是为了简化处理，因为后续更小的斐波那契数不可能再与前面的数组合成n
                    ans--;
                    break;
                }
                pre = 1; // 标记当前斐波那契数已被考虑
            } else {
                pre = 0; // 当前位为0，重置标记
            }
            k--; // 检查下一位
        }

        // 由于我们需要包括n本身，所以最后结果加1
        // 但实际上，由于上述逻辑中我们可能通过break提前结束了循环，且减去了一个多余的计数（如果有的话）
        // 所以这里的+1实际上是为了确保n本身被计入（如果n可以被表示为两个斐波那契数的和）
        // 如果n不能表示为两个斐波那契数的和，则上述循环结束后ans即为结果
        System.out.println(ans);
        return ans + 1;
    }

    public static void main(String[] args) {
        int n = 11;
        Solution600 solution600 = new Solution600();
        System.out.println(solution600.findIntegers(n));


    }
}